package com.telefonica.mistica.tokens.xml

import com.squareup.moshi.JsonAdapter
import com.telefonica.mistica.tokens.TokensGenerator.Companion.AUTOGENERATED_COMMENT
import com.telefonica.mistica.tokens.TokensGenerator.Companion.MISTICA_TOKENS_DIR
import com.telefonica.mistica.tokens.common.GetBorderRadiusName
import com.telefonica.mistica.tokens.dto.TokensDTO
import com.telefonica.mistica.tokens.dto.getHeterogeneousTokens
import com.telefonica.mistica.tokens.dto.removeHeterogeneousTokens
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.ATTRS_FILE
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.FONT_SUFFIX
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.TEXT_SIZE_SUFFIX
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.TEXT_STYLE_SUFFIX
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.TOOLS_NAMESPACE_ATTR
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.TOOLS_NAMESPACE_VALUE
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.VALUES_DIR
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.capitalizeString
import org.redundent.kotlin.xml.Node
import org.redundent.kotlin.xml.XmlVersion
import org.redundent.kotlin.xml.xml
import java.io.File

/**
 * Generates the `attrs_autogenerated.xml` file, which contains all the tokens defined in Mistica.
 */
class GenerateAttributesFile(
    private val getBorderRadiusName: GetBorderRadiusName = GetBorderRadiusName(),
) {

    operator fun invoke(jsonAdapter: JsonAdapter<TokensDTO>, heterogeneousTokensNames: List<String>) {
        val json = File("${MISTICA_TOKENS_DIR}/movistar.json").readText()
        val tokens = jsonAdapter.fromJson(json)

        if (tokens == null) {
            throw Exception("Invalid JSON")
        } else {
            val attributesXml = xml("resources", "utf-8", XmlVersion.V10) {
                attribute(TOOLS_NAMESPACE_ATTR, TOOLS_NAMESPACE_VALUE)
                comment(AUTOGENERATED_COMMENT)
                DECLARE_STYLEABLE {
                    getColorAttributes(tokens, heterogeneousTokensNames)
                }

                DECLARE_STYLEABLE {
                    getDrawableAttributes(tokens, heterogeneousTokensNames)
                }

                DECLARE_STYLEABLE {
                    getBorderRadiusAttributes(tokens)
                }

                DECLARE_STYLEABLE {
                    getPresetFontsAttributes(tokens)
                }

                DECLARE_STYLEABLE {
                    getPresetStylesAttributes(tokens)
                }

                DECLARE_STYLEABLE {
                    getPresetSizesAttributes(tokens)
                }
            }

            File("${VALUES_DIR}/${ATTRS_FILE}").writeText(attributesXml.toString())
        }
    }

    private fun Node.getColorAttributes(tokens: TokensDTO, heterogeneousTokensNames: List<String>) {
        attribute("name", "Colors")
        tokens.light.removeHeterogeneousTokens(heterogeneousTokensNames).forEach { color ->
            var key = color.key

            if (key == "controlActivated") {
                comment("We cannot use colorControlActivated in Android because it overlaps with a framework attribute")
                key = "controlActive"
            }

            ATTR {
                getColorElement("$BRAND_COLOR_PREFIX${key.capitalizeString()}")
            }
        }
    }

    private fun Node.getDrawableAttributes(tokens: TokensDTO, heterogeneousTokensNames: List<String>) {
        attribute("name", "Drawables")
        tokens.light.getHeterogeneousTokens(heterogeneousTokensNames).forEach { gradient ->
            val key = gradient.key
            ATTR {
                getReferenceElement("$BRAND_DRAWABLE_PREFIX${key.capitalizeString()}")
            }
        }
    }

    private fun Node.getColorElement(colorName: String) {
        attribute("name", colorName)
        attribute("format", "color|reference")
    }

    private fun Node.getReferenceElement(name: String) {
        attribute("name", name)
        attribute("format", "reference")
    }

    private fun Node.getBorderRadiusAttributes(tokens: TokensDTO) {
        attribute("name", "BorderRadius")
        tokens.radius.forEach { (key, _) ->
            ATTR {
                attribute("name", getBorderRadiusName(key))
                attribute("format", "dimension|fraction")
            }
        }
    }

    private fun Node.getPresetFontsAttributes(tokens: TokensDTO) {
        attribute("name", "PresetFonts")
        tokens.text.weight.forEach { (key, _) ->
            ATTR {
                attribute("name", "$key$FONT_SUFFIX")
                attribute("format", "string")
            }
        }
    }

    private fun Node.getPresetStylesAttributes(tokens: TokensDTO) {
        attribute("name", "PresetStyles")
        comment(
            "Important:\n" +
                    "        These constants are the same as \"android:textStyle\" flag values\n" +
                    "        and they have been replicated for each type of preset because\n" +
                    "        it's not possible to reference the original values out of android:textStyle usage."
        )
        tokens.text.weight.forEach { (key, _) ->
            ATTR {
                attribute("name", "$key$TEXT_STYLE_SUFFIX")
                attribute("format", "reference")
                FLAG {
                    attribute("name", "normal")
                    attribute("value", "0")
                }
                FLAG {
                    attribute("name", "bold")
                    attribute("value", "1")
                }
                FLAG {
                    attribute("name", "italic")
                    attribute("value", "2")
                }
            }
        }
    }

    private fun Node.getPresetSizesAttributes(tokens: TokensDTO) {
        attribute("name", "PresetSizes")
        tokens.text.size.forEach { (key, _) ->
            ATTR {
                attribute("name", "$key$TEXT_SIZE_SUFFIX")
                attribute("format", "dimension")
            }
        }
    }

    companion object {
        private const val DECLARE_STYLEABLE = "declare-styleable"
        private const val FLAG = "flag"
        private const val ATTR = "attr"

        const val BRAND_COLOR_PREFIX = "color"
        const val BRAND_DRAWABLE_PREFIX = "drawable"
    }
}