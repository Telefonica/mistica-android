package com.telefonica.mistica.tokens.xml

import com.squareup.moshi.JsonAdapter
import com.telefonica.mistica.tokens.Brand
import com.telefonica.mistica.tokens.TokensGenerator.Companion.AUTOGENERATED_COMMENT
import com.telefonica.mistica.tokens.TokensGenerator.Companion.BOLD
import com.telefonica.mistica.tokens.TokensGenerator.Companion.BRANDS
import com.telefonica.mistica.tokens.TokensGenerator.Companion.CIRCLE_RADIUS
import com.telefonica.mistica.tokens.TokensGenerator.Companion.LIGHT
import com.telefonica.mistica.tokens.TokensGenerator.Companion.MEDIUM
import com.telefonica.mistica.tokens.TokensGenerator.Companion.MISTICA_TOKENS_DIR
import com.telefonica.mistica.tokens.TokensGenerator.Companion.REGULAR
import com.telefonica.mistica.tokens.common.GetBorderRadiusName
import com.telefonica.mistica.tokens.common.GetColorResourceName
import com.telefonica.mistica.tokens.common.GetColorsWithAlpha
import com.telefonica.mistica.tokens.common.GetGradientDrawableResourceName
import com.telefonica.mistica.tokens.dto.BrushDTO
import com.telefonica.mistica.tokens.dto.RadiusDTO
import com.telefonica.mistica.tokens.dto.TextDTO
import com.telefonica.mistica.tokens.dto.TextSizeDTO
import com.telefonica.mistica.tokens.dto.TextWeightDTO
import com.telefonica.mistica.tokens.dto.TokensDTO
import com.telefonica.mistica.tokens.dto.getGradientTokens
import com.telefonica.mistica.tokens.dto.getGradientTokensNames
import com.telefonica.mistica.tokens.xml.GenerateMisticaCompatibilityGradientEnum.Companion.BRAND_GRADIENT_ANGLE_ATTR_PREFIX
import com.telefonica.mistica.tokens.xml.GenerateMisticaCompatibilityGradientEnum.Companion.BRAND_GRADIENT_COLORS_ATTR_PREFIX
import com.telefonica.mistica.tokens.xml.GenerateMisticaCompatibilityGradientEnum.Companion.BRAND_GRADIENT_STOPS_ATTR_PREFIX
import org.redundent.kotlin.xml.Node
import org.redundent.kotlin.xml.PrintOptions
import org.redundent.kotlin.xml.XmlVersion
import org.redundent.kotlin.xml.xml
import java.io.File

/**
 * Generates the `themes_xxx_autogenerated.xml` files for each brand.
 */
class GenerateXMLFiles(
    private val getColorsWithAlpha: GetColorsWithAlpha = GetColorsWithAlpha(),
    private val getColorResourceName: GetColorResourceName = GetColorResourceName(),
    private val getGradientDrawableResourceName: GetGradientDrawableResourceName = GetGradientDrawableResourceName(),
    private val generateAttributesFile: GenerateAttributesFile = GenerateAttributesFile(),
    private val getBorderRadiusName: GetBorderRadiusName = GetBorderRadiusName(),
    private val generateMisticaCompatibilityGradientEnum: GenerateMisticaCompatibilityGradientEnum = GenerateMisticaCompatibilityGradientEnum(),
    private val generateBrandGradientDrawables: GenerateBrandGradientDrawables = GenerateBrandGradientDrawables(),
) {

    operator fun invoke(jsonAdapter: JsonAdapter<TokensDTO>) {
        val brandTokens = BRANDS.map { brand ->
            val json = File("${MISTICA_TOKENS_DIR}/${brand.file}.json").readText()
            val tokens = jsonAdapter.fromJson(json) ?: throw Exception("Invalid JSON")
            tokens to brand
        }

        val gradientTokensNames = brandTokens
            .map { it.first }
            .getGradientTokensNames()

        generateAttributesFile(jsonAdapter, gradientTokensNames)
        generateMisticaCompatibilityGradientEnum(gradientTokensNames)

        brandTokens.forEach { (tokens, brand) ->
            generateColorsFiles(tokens, brand)
            generateBrandGradientDrawables(tokens, brand.name)
            generateCompatibilityGradientResourcesFile(tokens, brand, gradientTokensNames)
            generateLightThemesFiles(tokens, brand, gradientTokensNames)
            generateDarkThemesFiles(tokens, brand, gradientTokensNames)
        }

    }

    private fun generateColorsFiles(tokens: TokensDTO, brand: Brand) {
        val colorsWithAlpha = getColorsWithAlpha(tokens, brand.name)
        val colorsXml = xml("resources", "utf-8", XmlVersion.V10) {
            comment(AUTOGENERATED_COMMENT)

            tokens.global.palette.forEach { color ->
                val colorName = "${brand.name}_color_${color.key}"

                "color" {
                    attribute("name", colorName)
                    -color.value.value
                }
            }

            colorsWithAlpha.forEach { colorWithAlpha ->
                "color" {
                    attribute("name", colorWithAlpha.first)
                    -colorWithAlpha.second
                }
            }
        }

        File("$VALUES_DIR/${COLORS_FILE.format(brand.name)}").writeText(colorsXml.toString(PrintOptions(singleLineTextElements = true)))
    }

    private fun generateCompatibilityGradientResourcesFile(tokens: TokensDTO, brand: Brand, gradientTokensNames: List<String>) {
        val gradientResourcesXml = xml("resources", "utf-8", XmlVersion.V10) {
            comment(AUTOGENERATED_COMMENT)
            comment("Less than Api 24 Support Gradients Resources")
            comment("Light Gradient resources")
            createCompatibilityGradientResources(tokens.light.getGradientTokens(gradientTokensNames), brand, false)
            comment("Dark Gradient resources")
            createCompatibilityGradientResources(tokens.dark.getGradientTokens(gradientTokensNames), brand, true)
        }
        File("$VALUES_DIR/${COMPATIBILITY_GRADIENTS_FILE.format(brand.name)}").writeText(gradientResourcesXml.toString(PrintOptions(singleLineTextElements = true)))
    }

    private fun generateLightThemesFiles(
        tokens: TokensDTO,
        brand: Brand,
        gradientTokensNames: List<String>,
    ) {

        fun Node.generateTheme(themeName: String) {
            "style" {
                attribute("name", themeName)
                attribute("parent", "${themeName}_Customizations")
            }

            "style" {
                attribute("name", "${themeName}_Base")
                mapColorsAndGradients(tokens.light, brand, gradientTokensNames)
                mapCompatibilityGradients(brand, gradientTokensNames, false)
                borderRadius(tokens.radius)
                presetFonts(tokens.text)
                presetStyles(tokens.text.weight)
                presetSizes(tokens.text.size)
            }
        }

        val lightThemesXml = xml("resources", "utf-8", XmlVersion.V10) {
            comment(AUTOGENERATED_COMMENT)

            val brandName = brand.name.capitalizeString()

            generateTheme("MisticaTheme.$brandName")

            if (brand.createDuplicateWithoutInheritMistica) {
                generateTheme("${brandName}Override")
            }
        }

        File("$VALUES_DIR/${THEMES_FILE.format(brand.name)}").writeText(lightThemesXml.toString(PrintOptions(singleLineTextElements = true)))
    }

    private fun Node.borderRadius(radius: Map<String, RadiusDTO>) {
        comment("Border radius")
        radius.forEach { (key, radius) ->
            val value = if (radius.value == CIRCLE_RADIUS) "50%" else "${radius.value}dp"

            "item" {
                attribute("name", getBorderRadiusName(key))
                -value
            }
        }
    }

    private fun Node.presetFonts(text: TextDTO) {
        comment("Preset fonts")
        text.weight.forEach { (key, text) ->
            val value = when (text.value) {
                LIGHT -> "?font_family_light"
                REGULAR -> "?font_family_regular"
                MEDIUM -> "?font_family_medium"
                BOLD -> "?font_family_regular"
                else -> throw Exception("Invalid text weight")
            }

            "item" {
                attribute("name", "$key$FONT_SUFFIX")
                -value
            }
        }
    }

    private fun Node.presetStyles(weights: Map<String, TextWeightDTO>) {
        comment("Preset styles")
        weights.forEach { (key, text) ->
            val value = when (text.value) {
                LIGHT, REGULAR, MEDIUM -> "normal"
                BOLD -> "bold"
                else -> throw Exception("Invalid text weight")
            }

            "item" {
                attribute("name", "$key$TEXT_STYLE_SUFFIX")
                -value
            }
        }
    }

    private fun Node.presetSizes(sizes: Map<String, TextSizeDTO>) {
        comment("Preset sizes")
        sizes.forEach { (key, size) ->
            val value = "${size.value.mobile}sp"

            "item" {
                attribute("name", "$key$TEXT_SIZE_SUFFIX")
                -value
            }
        }
    }

    private fun generateDarkThemesFiles(
        tokens: TokensDTO,
        brand: Brand,
        gradientTokensNames: List<String>,
    ) {

        fun Node.generateTheme(themeName: String) {
            "style" {
                attribute("name", themeName)
                attribute("parent", "${themeName}_Customizations")
                mapColorsAndGradients(tokens.dark, brand, gradientTokensNames)
                mapCompatibilityGradients(brand, gradientTokensNames, true)
            }
        }

        val darkThemesXml = xml("resources", "utf-8", XmlVersion.V10) {
            comment(AUTOGENERATED_COMMENT)

            val brandName = brand.name.capitalizeString()

            generateTheme("MisticaTheme.$brandName")

            if (brand.createDuplicateWithoutInheritMistica) {
                generateTheme("${brandName}Override")
            }
        }

        File("$VALUES_NIGHT_DIR/${THEMES_FILE.format(brand.name)}").writeText(darkThemesXml.toString(PrintOptions(singleLineTextElements = true)))
    }

    private fun Node.mapColorsAndGradients(
        items: Map<String, BrushDTO>,
        brand: Brand,
        gradientTokensNames: List<String>
    ) {
        items.forEach { item ->
            val colorName = if (item.key == "controlActivated") {
                "colorControlActive"
            } else {
                if (item.key in gradientTokensNames) {
                    "drawable${item.key.capitalizeString()}"
                } else {
                    "color${item.key.capitalizeString()}"
                }
            }
            when (val itemValue = item.value) {
                is BrushDTO.SolidColorDTO ->
                    "item" {
                        attribute("name", colorName)
                        -"@color/${getColorResourceName(itemValue.value, brand.name)}"
                    }

                is BrushDTO.GradientDTO -> {
                    "item" {
                        attribute("name", colorName)
                        -"@drawable/${getGradientDrawableResourceName(brand.name, item.key)}"
                    }
                }
            }
        }
    }

    private fun Node.mapCompatibilityGradients(brand: Brand, gradientTokensNames: List<String>, isDark: Boolean) {
        comment("Less than Api 24 Support Gradients")
        gradientTokensNames.forEach { gradientName ->
            "item" {
                attribute("name", "$BRAND_GRADIENT_COLORS_ATTR_PREFIX${gradientName.capitalizeString()}")
                -"@array/${getGradientCompatibilityResourceName(brand.name, COMPATIBILITY_GRADIENT_COLORS_RESOURCE_INFIX, isDark, gradientName)}"
            }
            "item" {
                attribute("name", "$BRAND_GRADIENT_STOPS_ATTR_PREFIX${gradientName.capitalizeString()}")
                -"@array/${getGradientCompatibilityResourceName(brand.name, COMPATIBILITY_GRADIENT_STOPS_RESOURCE_INFIX, isDark, gradientName)}"
            }
            "item" {
                attribute("name", "$BRAND_GRADIENT_ANGLE_ATTR_PREFIX${gradientName.capitalizeString()}")
                -"@integer/${getGradientCompatibilityResourceName(brand.name, COMPATIBILITY_GRADIENT_ANGLE_RESOURCE_INFIX, isDark, gradientName)}"
            }
        }
    }

    private fun Node.createCompatibilityGradientResources(brushes: Map<String, BrushDTO>, brand: Brand, isDark: Boolean) {
        brushes.forEach { brushEntry ->
            val brush = brushEntry.value
            var angle = 0
            val colorStops = mutableListOf<Float>()
            val colorResourcesNames = mutableListOf<String>()
            when (brush) {
                is BrushDTO.SolidColorDTO -> {
                    colorStops.add(0F)
                    colorResourcesNames.add(getColorResourceName(brush.value, brand.name))
                }

                is BrushDTO.GradientDTO -> {
                    angle = brush.value.angle
                    brush.value.colors.forEach { color ->
                        colorStops.add(color.stop)
                        colorResourcesNames.add(getColorResourceName(color.value, brand.name))
                    }
                }
            }

            comment("${brushEntry.key} gradient")
            "integer-array" {
                attribute("name", getGradientCompatibilityResourceName(brand.name, COMPATIBILITY_GRADIENT_COLORS_RESOURCE_INFIX, isDark, brushEntry.key))
                colorResourcesNames.forEach { value ->
                    "item" {
                        -"@color/$value"
                    }
                }
            }
            "string-array" {
                attribute("name", getGradientCompatibilityResourceName(brand.name, COMPATIBILITY_GRADIENT_STOPS_RESOURCE_INFIX, isDark, brushEntry.key))
                colorStops.forEach { stop ->
                    "item" {
                        -"$stop"
                    }
                }
            }
            "integer" {
                attribute("name", getGradientCompatibilityResourceName(brand.name, COMPATIBILITY_GRADIENT_ANGLE_RESOURCE_INFIX, isDark, brushEntry.key))
                -"$angle"
            }
        }
    }

    private fun getGradientCompatibilityResourceName(
        brandName: String,
        resourceInfix: String,
        isDark: Boolean,
        tokenName: String,
    ) = "${brandName}_${resourceInfix}_${if(isDark) "dark" else "light"}_${tokenName}".lowercase()

    companion object {
        const val VALUES_DIR = "../library/src/main/res/values"
        private const val VALUES_NIGHT_DIR = "../library/src/main/res/values-night"

        const val DRAWABLE_DIR = "../library/src/main/res/drawable"
        const val DRAWABLE_NIGHT_DIR = "../library/src/main/res/drawable-night"

        private const val COLORS_FILE = "colors_%s_autogenerated.xml"
        private const val THEMES_FILE = "themes_%s_autogenerated.xml"
        const val ATTRS_FILE = "attrs_autogenerated.xml"
        const val TEXT_STYLE_SUFFIX = "TextStyle"
        const val TEXT_SIZE_SUFFIX = "TextSize"
        const val FONT_SUFFIX = "Font"

        const val GRADIENT_PACKAGE = "com.telefonica.mistica.theme.gradient"
        private const val COMPATIBILITY_GRADIENTS_FILE = "compatibility_gradients_%s_autogenerated.xml"

        private const val COMPATIBILITY_GRADIENT_COLORS_RESOURCE_INFIX = "gradient_colors"
        private const val COMPATIBILITY_GRADIENT_STOPS_RESOURCE_INFIX = "gradient_stops"
        private const val COMPATIBILITY_GRADIENT_ANGLE_RESOURCE_INFIX = "gradient_angle"

        const val TOOLS_NAMESPACE_ATTR = "xmlns:tools"
        const val TOOLS_NAMESPACE_VALUE = "http://schemas.android.com/tools"

        const val MIN_API_LEVEL_ATTR = "tools:targetApi"
        const val MIN_API_24_VALUE = "n"

        fun String.capitalizeString(): String =
            this.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
    }
}
