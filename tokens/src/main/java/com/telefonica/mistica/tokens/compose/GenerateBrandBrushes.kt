package com.telefonica.mistica.tokens.compose

import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.joinToCode
import com.telefonica.mistica.tokens.TokensGenerator
import com.telefonica.mistica.tokens.common.GetColorNameWithAlpha
import com.telefonica.mistica.tokens.compose.GenerateComposeFiles.Companion.angledLinearGradientClass
import com.telefonica.mistica.tokens.compose.GenerateComposeFiles.Companion.misticaBrushesClass
import com.telefonica.mistica.tokens.compose.GenerateComposeFiles.Companion.solidColorClass
import com.telefonica.mistica.tokens.dto.BrushDTO
import com.telefonica.mistica.tokens.dto.TokensDTO
import com.telefonica.mistica.tokens.dto.getGradientTokens
import com.telefonica.mistica.tokens.xml.GenerateXMLFiles.Companion.capitalizeString
import java.io.File

/**
 * Generates the XXXBrandBrushesAutogenerated.kt file for each brand.
 */
class GenerateBrandBrushes(
    private val getColorNameWithAlpha: GetColorNameWithAlpha = GetColorNameWithAlpha(),
) {

    operator fun invoke(tokens: TokensDTO, brandName: String, gradientTokensNames: List<String>) {
        val paletteClassName = "${brandName.capitalizeString()}PaletteColor"

        val lightProperty = PropertySpec.builder("lightBrushes", misticaBrushesClass)
            .initializer(getBrushesConstructor(brandName, tokens.light.getGradientTokens(gradientTokensNames), paletteClassName))
            .build()

        val darkProperty = PropertySpec.builder("darkBrushes", misticaBrushesClass)
            .initializer(getBrushesConstructor(brandName, tokens.dark.getGradientTokens(gradientTokensNames), paletteClassName))
            .build()

        val brushesObject = TypeSpec.objectBuilder("${brandName.capitalizeString()}BrandBrushes")
            .addProperty(lightProperty)
            .addProperty(darkProperty)
            .build()

        val file = FileSpec.builder("com.telefonica.mistica.compose.theme.brand", "${brandName.capitalizeString()}BrandBrushesAutogenerated")
            .addFileComment(TokensGenerator.AUTOGENERATED_COMMENT)
            .addType(brushesObject)
            .build()

        file.writeTo(File(GenerateComposeFiles.LIBRARY_CODE_PATH))
    }

    private fun getBrushesConstructor(
        brandName: String,
        brushes: Map<String, BrushDTO>,
        paletteClassName: String,
    ): CodeBlock {
        val assignments = brushes.map { (key, brush) ->
            when (brush) {
                is BrushDTO.SolidColorDTO -> {
                    val colorValue = getColorValue(brush.value, brush.description, brandName, paletteClassName)
                    CodeBlock.of("$key = %T($colorValue)", solidColorClass)
                }
                is BrushDTO.GradientDTO -> {
                    val angle = brush.value.angle
                    val colorStops = brush.value.colors.map { color ->
                        "${color.stop}F to ${getColorValue(color.value, brush.description, brandName, paletteClassName)}, "
                    }
                    CodeBlock.of("$key = %T(angleInDegrees=%L, colorStops=listOf(%L))", angledLinearGradientClass, angle, colorStops)
                }
            }
        }
        return CodeBlock.of("%T(%L)", misticaBrushesClass, assignments.joinToCode(separator = ",\n"))
    }

    private fun getColorValue(
        color: String,
        description: String,
        brandName: String,
        paletteClassName: String
    ): String {
        var colorValue = "${brandName}_color_${description}"
        if (color.contains("rgba(")) {
            val alpha = TokensGenerator.ALPHA_REGEX.find(color)?.value?.toDouble()
            if (alpha != null) {
                colorValue = getColorNameWithAlpha(brandName, description, alpha)
            }
        }
        return "$paletteClassName.$colorValue"
    }
}
