package com.telefonica.mistica.tokens

import com.squareup.moshi.JsonAdapter
import com.telefonica.mistica.tokens.GenerateTokens.Companion.ALPHA_REGEX
import com.telefonica.mistica.tokens.GenerateTokens.Companion.AUTOGENERATED_COMMENT
import com.telefonica.mistica.tokens.GenerateTokens.Companion.BRANDS
import com.telefonica.mistica.tokens.GenerateTokens.Companion.MISTICA_TOKENS_DIR
import com.telefonica.mistica.tokens.dto.ColorDTO
import com.telefonica.mistica.tokens.dto.TokensDTO
import org.redundent.kotlin.xml.XmlVersion
import org.redundent.kotlin.xml.xml
import java.io.File
import java.util.Locale
import kotlin.math.roundToInt

class GenerateXML {

    operator fun invoke(jsonAdapter: JsonAdapter<TokensDTO>) {
        GenerateAttributesFile().invoke(jsonAdapter)

        BRANDS.forEach { brand ->
            val json = File("${MISTICA_TOKENS_DIR}/$brand.json").readText()
            val tokens = jsonAdapter.fromJson(json)
            if (tokens == null) {
                throw Exception("Invalid JSON")
            } else {
                generateColorsFiles(tokens, brand)
                generateLightThemesFiles(tokens, brand)
                generateDarkThemesFiles(tokens, brand)
            }
        }

    }

    private fun generateLightThemesFiles(tokens: TokensDTO, brand: String) {
        val lightThemesXml = xml("resources", "utf-8", XmlVersion.V10) {
            comment(AUTOGENERATED_COMMENT)

            "style" {
                attribute("name", "MisticaTheme.${brand.capitalizeString()}")
                attribute("parent", "MisticaTheme.${brand.capitalizeString()}_Customizations")
            }

            "style" {
                attribute("name", "MisticaTheme.${brand.capitalizeString()}_Base")

                tokens.light.forEach { color ->
                    val colorName = if (color.key == "controlActivated") {
                        "colorControlActive"
                    } else {
                        "color${color.key.capitalizeString()}"
                    }

                    if (color.value.value.contains("rgba(")) {
                        val alpha = ALPHA_REGEX.find(color.value.value)?.value?.toDouble()
                        if (alpha != null) {
                            val colorValue = getColorNameWithAlpha(brand, color.value.description, alpha)
                            "item" {
                                attribute("name", colorName)
                                -"@color/$colorValue"
                            }
                        }
                    } else {
                        "item" {
                            attribute("name", colorName)
                            -"@color/${brand}_color_${color.value.description}"
                        }
                    }
                }
            }
        }

        File("$VALUES_DIR/${THEMES_FILE.format(brand)}").writeText(lightThemesXml.toString())
    }

    private fun generateDarkThemesFiles(tokens: TokensDTO, brand: String) {
        val darkThemesXml = xml("resources", "utf-8", XmlVersion.V10) {
            comment(AUTOGENERATED_COMMENT)

            "style" {
                attribute("name", "MisticaTheme.${brand.capitalizeString()}")
                attribute("parent", "MisticaTheme.${brand.capitalizeString()}_Customizations")

                tokens.dark.forEach { color ->
                    val colorName = if (color.key == "controlActivated") {
                        "colorControlActive"
                    } else {
                        "color${color.key.capitalizeString()}"
                    }

                    "item" {
                        attribute("name", colorName)
                        -"@color/${brand}_color_${color.value.description}"
                    }
                }
            }
        }

        File("$VALUES_NIGHT_DIR/${THEMES_FILE.format(brand)}").writeText(darkThemesXml.toString())
    }

    private fun generateColorsFiles(tokens: TokensDTO, brand: String) {
        val colorsWithAlpha = getColorsWithAlpha(tokens, brand)
        val colorsXml = xml("resources", "utf-8", XmlVersion.V10) {
            comment(AUTOGENERATED_COMMENT)

            tokens.global.palette.forEach { color ->
                val colorName = "${brand}_color_${color.key}"

                "color" {
                    attribute("name", colorName)
                    -color.value.value
                }
            }

            colorsWithAlpha.forEach { colorWithAlpha ->
                "color" {
                    attribute("name", colorWithAlpha.first)
                    -colorWithAlpha.second
                }
            }
        }

        File("$VALUES_DIR/${COLORS_FILE.format(brand)}").writeText(colorsXml.toString())
    }

    private fun getColorsWithAlpha(tokens: TokensDTO, brand: String): List<Pair<String, String>> {
        val colorsWithAlpha = mutableSetOf<Pair<String, String>>()
        tokens.light.values.forEach { color ->
            val colorWithAlpha = getAlphaColor(color, tokens, brand)
            if (colorWithAlpha != null) {
                colorsWithAlpha.add(colorWithAlpha)
            }
        }

        tokens.dark.values.forEach { color ->
            val colorWithAlpha = getAlphaColor(color, tokens, brand)
            if (colorWithAlpha != null) {
                colorsWithAlpha.add(colorWithAlpha)
            }
        }

        return colorsWithAlpha.toList()
    }

    private fun getAlphaColor(
        color: ColorDTO,
        tokens: TokensDTO,
        brand: String,
    ): Pair<String, String>? {
        if (color.value.contains("rgba(")) {
            val alpha = ALPHA_REGEX.find(color.value)?.value?.toDouble()

            val colorValue = tokens.global.palette[color.description]?.value
            if (alpha != null && colorValue != null) {
                val alphaHex = alpha.toHex()
                val colorName = getColorNameWithAlpha(brand, color.description, alpha)
                val colorWithAlpha = "#" + alphaHex + colorValue.removePrefix("#")
                return colorName to colorWithAlpha
            }
        }
        return null
    }

    private fun getColorNameWithAlpha(
        brand: String,
        colorDescription: String,
        alpha: Double,
    ) = "${brand}_color_${colorDescription}_${(alpha * 100).toInt()}_alpha"

    private fun Double.toHex(): String {
        val i = (this * 100).roundToInt() / 100.0
        val alpha = (i * 255).roundToInt()
        return Integer.toHexString(alpha)
            .uppercase(Locale.getDefault())
            .padStart(2, '0')
    }

    companion object {
        const val VALUES_DIR = "../library/src/main/res/values"
        private const val VALUES_NIGHT_DIR = "../library/src/main/res/values-night"
        private const val COLORS_FILE = "colors_%s_autogenerated.xml"
        private const val THEMES_FILE = "themes_%s_autogenerated.xml"
        const val ATTRS_FILE = "attrs_autogenerated.xml"

        fun String.capitalizeString(): String =
            this.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
    }
}
